## required packages library(compiler)library(geepack)library(boot)## generate data function  gendat.src <- function(numCl = 50, numRep = 4, monotonicity = FALSE, betas=c(1,3,-2), 		thetas=c(.5,1,-2), corstr = "ar1"){		## generate data 	numObs <- numRep*numCl	id <- gl(numCl, numRep, numObs)	visit <- rep(1:numRep, numCl)	x1 <- rbinom(numObs, 1, 0.6) ## within cluster varying binary covariate	x2 <- runif(numObs, 0, 1)   ## within cluster varying continuous covariate	phi <- 1 + 2 * x1         ## true scale model		## specify inter-cluster correlation	## there are three choices	if(corstr=="ar1"){		rhomat <- 0.667 ^ outer(1:numRep, 1:numRep, function(x, y) abs(x - y))	}else if(corstr=="exch"){		rhomat <- (0.667*outer(1:numRep, 1:numRep, function(x, y) x!=y)+diag(x=1,nrow=numRep))	}else if(corstr=="indep"){		rhomat <- diag(x=1,nrow=numRep)	}	chol.u <- chol(rhomat)	noise <- as.vector(sapply(1:numCl, function(x) chol.u %*% rnorm(numRep)))	e <- sqrt(phi) * noise	y <- betas[1] + (betas[2]*x1) + (betas[3]*x2) + e	dat <- data.frame(y, id, visit, x1, x2)		## generate some probabilities of remaining in study #                   	if(monotonicity == FALSE){			logit.p <- rep(0,numObs)		p <- rep(.5,numObs)		## true model of missingness		## logistic model		logit.p <- thetas[1] + (thetas[2]*dat$x1) + (thetas[3]*dat$x2)		p <- inv.logit(logit.p)		}	dat$p <- p	#TO DO: add monotonicity option			# specify if responses are observed #	    	r <- rep(1,numObs)	for(i in 1:numObs){		r[i] <- rbinom(1,1,p[i])	}	dat$r <- r		dat$yObs <- dat$y  dat$yObs[which(dat$r==0)] <- NA		return(dat)}gendat <- cmpfun(gendat.src)## get weights function getweights.src <- function(r, x1, x2){	weights <- rep(1,length(r))	mod <- glm(r ~ x1 + x2, family = binomial)	weights <- r/(mod$fitted.values)	return(weights)}getweights <- cmpfun(getweights.src)## do 1 replication function do1.src <- function(numCl=150, numRep=4, corstr="ar1", thetas=c(.5,1,-2), sformula = ~x1){  	data <- gendat(numCl=numCl, numRep=numRep, corstr=corstr, thetas = thetas)	data$weights <- getweights(data$r, data$x1, data$x2)	fitWeights <- geese(yObs ~ x1 + x2, id = id, data = data, corstr = corstr, sformula = sformula, weights = weights)	fitNoWeight <- geese(yObs ~ x1 + x2, id = id, data = data, corstr = corstr, sformula = sformula)    #THIS NEEDS TO BE MORE GENERAL  ret <- c(fitWeights$beta, fitNoWeight$beta ,fitWeights$alpha, fitNoWeight$alpha, fitWeights$gamma, fitNoWeight$gamma, sqrt(diag(fitWeights$vbeta)),            sqrt(diag(fitNoWeight$vbeta)), sqrt(fitWeights$valpha), sqrt(fitNoWeight$valpha), sqrt(diag(fitWeights$vgamma)), sqrt(diag(fitNoWeight$vgamma)))  	return(ret)}do1 <- cmpfun(do1.src)## simulate reps <- 1000results <- replicate(reps, do1(numCl=150,numRep=4,corstr="ar1", thetas=c(.5,1,-2), sformula=~x1)) results <- t(results)             #each row is one replicationaverages <- c(mean(results[,1]), mean(results[,2]), mean(results[,3]), mean(results[,4]), mean(results[,5]), mean(results[,6]), mean(results[,7]), mean(results[,8]),   mean(results[,9]), mean(results[,10]), mean(results[,11]), mean(results[,12]), mean(results[,13]), mean(results[,14]), mean(results[,15]), mean(results[,16]),   mean(results[,17]), mean(results[,18]), mean(results[,19]), mean(results[,20]), mean(results[,21]), mean(results[,22]), mean(results[,23]), mean(results[,24]))cnames <- c("b1w", "b2w", "b3w", "b1u", "b2u", "b3u", "aw", "au", "g1w", "g2w", "g1u", "g2u", "seb1w",                         "seb2w", "seb3w", "seb1u", "seb2u", "seb3u", "seaw", "seau", "seg1w", "seg2w",                         "seg1u", "seg2u", "empSEb1w", "empSEb2w", "empSEb3w", "empSEb1u", "empSEb2u",                         "empSEb3u")averages <- c(averages, sd(results[,1]), sd(results[,2]), sd(results[,3]), sd(results[,4]), sd(results[,5]), sd(results[,6]))table <- rbind(cnames, averages)##  COMPARE STUFF ## TO DO## to take average of a bunch of matrices in a list, use Reduce('+', betaCovWeight)/length(betaCovWeight)##